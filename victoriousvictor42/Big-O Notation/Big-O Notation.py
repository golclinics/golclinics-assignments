# -*- coding: utf-8 -*-
"""Big-O-analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vuFr1FjTBKI5bMS9xMXJ7j_0rcQIjGL5

# Analysis the space and time complexities of the following algorithms

## 1. Countdown

###Given an integer n as input countdown(n) prints the numbers n to 1 in descending order then prints "Blast off!"
"""

def countdown(n):
    while n > 0:
        print(n)
        n -= 1
    print("Blast off!")

"""this is a O(n), linear time complexity, because when an X,Y-axis gets drawn, the time and input variables will be proportional and thus forming a straight line.

## 2. Countdown recursive

### This solves the same problem as the previous algorithm, but uses recursion instead of a loop. This might not be obvious if you're not familiar with function call stacks. Bonus points if you can explain why the space complexity here is not the same as the space complexity of the loop-based implementation. Feel free to research on the Internet.
"""

def countdown_recursive(n):
    if n == 0:
        print("Blast off")
    else:
        print(n)
        countdown_recursive(n - 1)

"""This will be a O(1), constant time complexity, this is because, if the input is 0, we will end up with the result as "Blast off" and if its another number, but 0, that is n, we will first get the result as n and then get the second result as n-1 that are both constants.

### REASON FOR THE DIFFERENCE IN TIME COMPLEXITY

Countdown, O(n) (Linear time complexity),  the size of the input changes as time is increasing but in a straight line when the results are put in X,Y-axis graph, while in countdown recursive, O(1) (constant time complexity), the results are the same as the input (constant), that is 0 and n. It only changes to n-1, in which, n-1 is still a constant.

# 3. Palindrome

## Given a string s as input, the is_palindrome(s) function returns true if s is a palindrome and returns false otherwise. A palindrom in this case is a word that reads the same forward and backwards, e.g. madam
"""

def is_palindrome(s):
    if len(s) == 0:
        return True   # an empty string is a palindrome

    size = len(s)
    midpoint = size // 2
    
    for i in range(midpoint + 1):
        if s[i] != s[size - i - 1]:
            return False
    return True

"""Constant time complexity, O(1). This is because all the return statement returns a boolean output in which we see it as a constant for the If (conditional) statement. 
In the first part, if there is no word, which is 0, the function returns true, which justifies that this is a O(1) because the length of no word is 0.
In the for loop, the first 3 letters are matched with the last 3 letters because the word we are using as an example is madam, we find out that it returns true because they are matching as a result of the If statement. We affirm that this a O(1) because the result is a constant.

# 4. Palindrome using reversed string

## This solves the palindrome problem stated above by comparing the original string with the reversed version of the string:
"""

def is_palindrome_rev(s):
    reversed_s = s[::-1] # This is a neat trick to reverse a string in python
    return s == reversed_s

"""Constant time complexity, O(1). This is because the return statement is basically an if statement that shall return true if the original word matches with the reversed word. The function returns false if there is no match.

## The above method uses the fancy slicing feature in Python [::-1] which reverses a sequence. The following implementation
"""

def is_palindrome_rev2(s):
    reversed_seq = reversed(s) # creates a sequence with the characters in the string in reverse
    reversed_s = ''.join(reversed_seq) # transformed the reversed sequence into a string
    return s == reversed_s

"""Constant time complexity, O(1), this is because the return statement is basically an if statement. It returns true when the original word matches with the reversed word that was formed after joining. It turns false if there is no match.

# 5. Palindrome using recursion

## This implementation is similar to the loop-based version in that it compares a pair of letters at equal distances from the middle of the string in each iteration. But it does so using recursion instead of a loop:
"""

def is_palindrome_recur(s):
    if len(s) == 0:
        return True
    if len(s) == 1:
        return True
    
    # in python s[-1] is the last element of the sequence s, i.e. "madam"[-1] -> "m"
    # and s[1: -1] will create a slice starting from the second element to the second last element
    # "madam"[1: -1] -> "ada"
    return s[0] == s[-1] and is_palindrome_recur(s[1:-1])

"""Constant time complexity, O(1), this is because the return statement is basically an if statement. It will return true if the following conditions are met, which is, the first and the last letters match after slicing and they fit with the middle part that was also sliced off from the word. The function returns false if the above stated conditions is not met."""

